# 设计：视口稳定性优化

## 逻辑分析

### 1. `isInside` 判定
当前代码：
```typescript
const isInside = 
    boardX >= pageSafeMinX &&
    (boardX + boardWidth) <= pageSafeMaxX &&
    boardY >= pageSafeMinY &&
    (boardY + boardHeight) <= pageSafeMaxY
```
这个逻辑是正确的：如果新画板的边界完全在 Page Safe Rect 内，则视为 Inside。

### 2. 为什么依然会移动？
如果用户感觉“在同一行内生成，视口也会横向移动”，可能有以下原因：
1. `pageSafeMinX` / `pageSafeMaxX` 计算有误（例如未考虑 Sidebar 变化）。
2. 新画板确实略微超出了右侧边缘（即使只有 1px），导致进入 `else` 分支，然后触发了“居中联合包围盒”的逻辑，导致视口大动干戈地移动。

### 3. 改进策略
当 `isInside` 为 `false` 时（即内容超出），我们目前的逻辑是：
- 计算 Union Bounds (当前视口 + 新画板)。
- 缩放以适应 Union Bounds。
- **居中显示** Union Bounds。

**问题在于“居中显示”**。如果我只是向右超出一点点，Union Bounds 变大了，为了居中 Union Bounds，视口会向右移动一半的增量。这导致左侧的内容也会跟着移动。

**新策略 (根据用户需求)**：
1. **Rule 1 (同一行/横向扩展)**: 如果新内容只是横向超出（Y轴未超出），且当前缩放比例足够容纳新内容（或者缩放后可以容纳）：
   - 尽量**保持视口左边缘不变**（或者只向右扩展），而不是重新居中整个联合区域。
   - 但用户的需求是：“如果超出视口，则平移时候到恰好装下新的产物”。这听起来像是要让新产物“进入视野”。

用户说：“当新建一行的时候，如果超出视口，则平移时候到恰好装下新的产物”。这其实就是我们之前的“最小缩放平移”逻辑的变体。

**核心矛盾**：用户希望“稳定”。
- 如果在视野内 -> 不动 (已实现，需验证)。
- 如果超出 -> 调整。

**猜测**：用户遇到的“移动”可能是因为新画板生成的位置（Auto Layout）稍微有点偏右，或者之前的视口并没有完全居中，导致每次生成都触发 `isInside = false`。

### 方案
我们将调整 `else` 分支（即超出视口时）的逻辑：
不再盲目地“居中 Union Bounds”。而是：
1. 计算能够包含 Union Bounds 的 Target Zoom。
2. 计算 Target Camera 位置。
   - 如果是**换行**（Y轴变化显著）：使用之前的“平移到底部对齐”或“居中”逻辑。
   - 如果是**同行**（Y轴基本不变）：尝试**锁定左边界**。即：如果当前视口的左边缘已经包含了旧内容，我们希望缩放/移动后，旧内容依然在原来的相对位置（视觉上不横移），或者至少视口不应该向右猛跳。

**简化方案**：
用户提到：“横向同一行内生成的时候，没有触碰到安全视口的边缘，则应该保持视口稳定”。
这意味着 `isInside` 判定必须非常精准。我们将添加日志来调试为什么它被判定为 `false`。

另外，针对 **2. 当新建一行的时候...平移时候到恰好装下新的产物**：
这其实就是我们刚才做的“最小缩放平移”逻辑。

**重点**：为什么“同一行”会移动？
可能是因为 `safeArea.right` (Sidebar) 的计算。

我们将：
1. 增加 `isInside` 的容错（Buffer），比如允许 1px 的误差。
2. 确保 `isInside` 逻辑生效。
